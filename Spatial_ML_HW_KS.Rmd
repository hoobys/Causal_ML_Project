---
title: "Causal Machine Learning for Spatial Data Project - UK road safety accidents"
authors: "Hubert Wojewoda, Kacper Sokołowski"
output:
  html_document:
    df_print: paged
---

```{r}
# Load libraries
library(tidyverse)
library(readr)
library(lubridate)
library(ggplot2)
library(sf)
library(here)
library(dbscan)
library(leaflet)
library(geosphere)
library(randomForest)
library(pROC)
library(caret)
library(viridis)
library(ggridges)
library(xgboost)
library(DALEX)

# Set working directory
setwd(here())
```

```{r}
# Load data
accident_data <- read_csv("accident_data.csv")

summary(accident_data)
head(accident_data)
```

```{r}
# Remove unnecessary columns
accident_data <- accident_data %>%
  select(
    Longitude, Latitude,
    Accident_Severity,
    Date, Time,
    Weather_Conditions, Light_Conditions,
    Road_Surface_Conditions,
    Speed_limit,
    Urban_or_Rural_Area,
    Number_of_Casualties, Number_of_Vehicles
  )
```


```{r}
# Remove observations with missing values
accident_data <- accident_data %>%
  filter(!is.na(Longitude), !is.na(Latitude))
```

```{r}
# Encode the target variable
accident_data$Accident_Severity <- accident_data$Accident_Severity %>%
  recode("Slight" = 0, "Severe" = 1, "Fatal" = 1)

# Format the date and time variables
accident_data$Date <- as.Date(accident_data$Date, format = "%Y-%m-%d")
accident_data$Year <- format(accident_data$Date, "%Y")

accident_data$Day_of_Week <- weekdays(accident_data$Date)
accident_data$Month <- format(accident_data$Date, "%m")
accident_data$Hour <- hour(hms(accident_data$Time))

accident_data$TimeOfDay <- cut(accident_data$Hour,
  breaks = c(-Inf, 6, 12, 18, Inf),
  labels = c("Night", "Morning", "Afternoon", "Evening")
)
```

```{r}
# Convert Longitude and Latitude to a matrix
coordinates <- as.matrix(accident_data[, c("Longitude", "Latitude")])
```

```{r}
# Perform DBSCAN clustering
dbscan_result <- dbscan(coordinates, eps = 0.1, minPts = 500)

# Extract cluster labels
cluster_labels <- dbscan_result$cluster
accident_data$Cluster <- cluster_labels

# Filter the accident_data dataframe to include only observations in a cluster
clustered_accident_data <- accident_data[accident_data$Cluster > 0, ]
```

```{r}
# Calculate the centroids of the clusters
centroids <- tapply(
  seq_len(nrow(clustered_accident_data)),
  clustered_accident_data$Cluster,
  function(rows) colMeans(clustered_accident_data[rows, 1:2])
)

# Calculate the distance from each point to its closest centroid
accident_data$DistanceToHotspot <- apply(coordinates, 1, function(coord) {
  min(sapply(centroids, function(centroid) dist(rbind(coord, centroid))))
})
```

```{r}
summary(accident_data$DistanceToHotspot)
```

```{r}
# Create a color palette for clusters
cluster_palette <- colorFactor(
  palette = "Set1",
  domain = clustered_accident_data$Cluster
)

# Create a leaflet map with a random sample of points
map <- leaflet() %>%
  addTiles() %>%
  addCircleMarkers(
    data = sample_n(clustered_accident_data, size = 10000),
    lng = ~Longitude,
    lat = ~Latitude,
    color = ~ cluster_palette(Cluster),
    radius = 3,
    popup = ~ paste("Grid Cell:", Cluster)
  )
map
```

```{r}
# Filter unnecessary columns
accident_data <- accident_data[, !(names(accident_data) %in% c(
  "Longitude", "Latitude", "Cluster", "Hour",
  "Number_of_Casualties", "Date", "Time", "Year"
))]

# Remove observations with missing values
accident_data <- accident_data[!is.na(accident_data$Accident_Severity), ]

# Convert all columns to factors
accident_data <- accident_data %>%
  mutate_if(is.character, as.factor)

summary(accident_data)
```
EDA
```{r}
ggplot(
  accident_data,
  aes(x = factor(Accident_Severity), fill = factor(Accident_Severity))
) +
  geom_bar(stat = "count") +
  scale_fill_manual(
    values = c("0" = "blue", "1" = "red"),
    labels = c("0" = "Slight", "1" = "Severe or Fatal"),
    name = "Accident Severity"
  ) +
  labs(
    x = "Accident Severity",
    y = "Count",
    title = "Distribution of Accident Severity"
  ) +
  theme_minimal()
```

```{r}
ggplot(accident_data, aes(x = Speed_limit, fill = ..count..)) +
  geom_histogram(binwidth = 10, color = "black", show.legend = FALSE) +
  scale_fill_viridis(name = "Frequency", option = "D") +
  labs(
    x = "Speed Limit",
    y = "Frequency",
    title = "Distribution of Speed Limits"
  ) +
  theme_minimal()
```
```{r}
ggplot(accident_data, aes(x = Weather_Conditions, fill = Weather_Conditions)) +
  geom_bar() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(
    title = "Accidents in Different Weather Conditions",
    x = "Weather Conditions",
    y = "Count"
  )
```

```{r}
day_mapping <- setNames(
  c(
    "Monday", "Tuesday", "Wednesday", "Thursday",
    "Friday", "Saturday", "Sunday"
  ),
  c(
    "poniedziałek", "wtorek", "środa", "czwartek",
    "piątek", "sobota", "niedziela"
  )
)

accident_data$Day_of_Week <- day_mapping[accident_data$Day_of_Week]
```

```{r}
ggplot(accident_data, aes(x = Day_of_Week, fill = factor(Accident_Severity))) +
  geom_bar(position = "dodge") +
  scale_fill_manual(
    values = c("0" = "lightblue", "1" = "red"),
    labels = c("0" = "Slight", "1" = "Severe or Fatal"),
    name = "Accident Severity"
  ) +
  labs(
    x = "Day of the Week",
    y = "Count",
    title = "Day of the Week vs Accident Severity"
  ) +
  theme_light() +
  theme(
    panel.background = element_rect(fill = "white", colour = "white"),
    plot.background = element_rect(fill = "white", colour = NA),
    legend.background = element_rect(fill = "white", colour = NA),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```
```{r}
ggplot(accident_data, aes(x = TimeOfDay, fill = factor(Accident_Severity))) +
  geom_bar(position = "dodge") +
  scale_fill_manual(
    values = c("0" = "lightblue", "1" = "red"),
    labels = c("0" = "Slight", "1" = "Severe or Fatal"),
    name = "Accident Severity"
  ) +
  labs(
    x = "Time of Day",
    y = "Count",
    title = "Time of Day vs Accident Severity"
  ) +
  theme_light() +
  theme(
    panel.background = element_rect(fill = "white", colour = "white"),
    plot.background = element_rect(fill = "white", colour = NA),
    legend.background = element_rect(fill = "white", colour = NA),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

```{r}
ggplot(accident_data, aes(x = DistanceToHotspot)) +
  geom_density(fill = "skyblue", alpha = 0.5) +
  xlim(0, 2) +
  labs(
    x = "Distance to Hotspot",
    y = "Density",
    title = "Empirical Density Function of Distance to Hotspot"
  ) +
  theme_minimal()
```
```{r}
ggplot(
  accident_data,
  aes(x = factor(Accident_Severity), y = DistanceToHotspot)
) +
  geom_violin(trim = FALSE, fill = "skyblue", color = "black") +
  scale_x_discrete(
    name = "Accident Severity",
    labels = c("0" = "Slight", "1" = "Severe or Fatal")
  ) +
  theme_minimal()
```

```{r}
ggplot(
  accident_data,
  aes(x = DistanceToHotspot, fill = factor(Accident_Severity))
) +
  geom_density(alpha = 0.5) +
  facet_grid(Accident_Severity ~ .) +
  scale_x_continuous(limits = c(0, 2)) +
  scale_fill_manual(
    values = c("0" = "lightblue", "1" = "red"),
    labels = c("0" = "Slight", "1" = "Severe or Fatal"),
    name = "Accident Severity"
  ) +
  theme_minimal()
```

```{r}
# Split the data into training and testing sets
set.seed(123)
train_indices <- createDataPartition(
  accident_data$Accident_Severity,
  p = 0.7, list = FALSE
)
train_data <- accident_data[train_indices, ]
test_data <- accident_data[-train_indices, ]

# Create the xgboost model
params <- list(
  objective = "binary:logistic",
  eval_metric = "logloss",
  eta = 0.1,
  max_depth = 4,
  subsample = 0.8,
  colsample_bytree = 0.8
)

# Convert the data to numeric
train_data_numeric <- train_data %>%
  mutate_if(is.factor, as.numeric)
test_data_numeric <- test_data %>%
  mutate_if(is.factor, as.numeric)

# Now use this numeric data in your model
model <- xgboost(
  data = as.matrix(train_data_numeric %>% select(-Accident_Severity)),
  label = train_data$Accident_Severity,
  params = params,
  nrounds = 100
)
# Make predictions on the test data
predictions <- predict(
  model,
  as.matrix(test_data_numeric %>% select(-Accident_Severity))
)
```

```{r}
summary(train_data_numeric)

# Accuracy
mean(ifelse(predictions > 0.5, 1, 0) == test_data$Accident_Severity)
```
```{r}
# AUC score
roc_obj <- roc(test_data$Accident_Severity, predictions)
auc_value <- auc(roc_obj)
print(auc_value)
```
```{r}
# Plot the ROC curve
plot(roc_obj, main = "ROC")
```

```{r}
# Feature importance
xgb.importance(model = model)

# Show importance plot with ggplot2
xgb.importance(model = model) %>%
  as.data.frame() %>%
  ggplot(aes(x = reorder(Feature, Gain), y = Gain)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  theme_bw()
```

```{r}
accident_data_matrix <- as.matrix(
  accident_data %>%
    select(-Accident_Severity) %>%
    mutate_if(is.factor, as.numeric)
)
accident_data_y <- accident_data$Accident_Severity

# Create an explainer for your model
explainer <- DALEX::explain(
  model = model,
  data = accident_data_matrix,
  y = accident_data_y,
)

# Variable Importance Plot
vi <- variable_importance(explainer)
plot(vi)

# Partial Dependence Plot for a Speed_limit variable
sl_pdp <- model_profile(explainer, variables = "Speed_limit")
plot(sl_pdp)

# Patrial Dependence Plot for a DistanceToHotspot variable
dth_pdp <- model_profile(explainer, variables = "DistanceToHotspot")
plot(dth_pdp)

# Break Down Plot for a single prediction
first_observation <- accident_data_matrix[1, , drop = FALSE]
bd <- predict_parts(
  explainer,
  new_observation = first_observation
)
plot(bd)

# Shapley Values Plot for a single prediction
sv <- predict_parts(
  explainer,
  new_observation = first_observation,
  type = "shap"
)
plot(sv)
```