---
title: "UK road safety accidents"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
library(tidyverse)
library(readr)
library(lubridate)
library(ggplot2)
library(sf)
library(here)
library(dbscan)
library(leaflet)
library(geosphere)
library(randomForest)
library(pROC)
library(caret)

setwd(here())
```

```{r}
accident_data <- read_csv("accident_data.csv")

summary(accident_data)
head(accident_data)
```

```{r}
unique(accident_data$Year)
```


```{r}
accident_data <- accident_data %>%
  select(
    Longitude, Latitude,
    Accident_Severity,
    Date, Time,
    Weather_Conditions, Light_Conditions,
    Road_Surface_Conditions,
    "1st_Road_Class", "2nd_Road_Class",
    Speed_limit,
    "Pedestrian_Crossing-Human_Control",
    "Pedestrian_Crossing-Physical_Facilities",
    Urban_or_Rural_Area,
    Number_of_Casualties, Number_of_Vehicles
  )
```


```{r}
accident_data <- accident_data %>%
  filter(!is.na(Longitude), !is.na(Latitude))
```

```{r}
accident_data$Accident_Severity <- accident_data$Accident_Severity %>%
  recode("Slight" = 0, "Severe" = 1, "Fatal" = 1)

accident_data$Date <- as.Date(accident_data$Date, format = "%Y-%m-%d")
accident_data$Year <- format(accident_data$Date, "%Y")

accident_data$Day_of_Week <- weekdays(accident_data$Date)
accident_data$Month <- format(accident_data$Date, "%m")
accident_data$Hour <- hour(hms(accident_data$Time))

accident_data$TimeOfDay <- cut(accident_data$Hour,
  breaks = c(-Inf, 6, 12, 18, Inf),
  labels = c("Night", "Morning", "Afternoon", "Evening")
)
```

```{r}
# Convert Longitude and Latitude to a matrix
coordinates <- as.matrix(accident_data[, c("Longitude", "Latitude")])
```

```{r}
# Perform DBSCAN clustering
dbscan_result <- dbscan(coordinates, eps = 0.1, minPts = 500)

# Extract cluster labels
cluster_labels <- dbscan_result$cluster

# Add cluster labels to the accident_data dataframe
accident_data$Cluster <- cluster_labels

# Filter the accident_data dataframe to include only observations in a cluster
clustered_accident_data <- accident_data[accident_data$Cluster > 0, ]
```

```{r}
calculate_centroids <- function(data, cluster_label) {
    centroids <- matrix(nrow = max(cluster_label), ncol = ncol(data))
    for (cl in 1:max(cluster_label)) {
        centroids[cl, ] <- colMeans(data[cluster_label == cl, ])
    }
    return(centroids)
}

centroids <- calculate_centroids(coordinates, cluster_labels)

# 2. Compute Distances
calculate_distances <- function(data, centroids, cluster_label) {
    distances <- numeric(nrow(data))
    for (i in 1:nrow(data)) {
        cl <- cluster_label[i]
        if (cl > 0 && !is.na(centroids[cl, 1])) {
            distances[i] <- distm(data[i, , drop = FALSE], centroids[cl, , drop = FALSE], fun = distHaversine)
        } else {
            distances[i] <- NA  # Assign NA to noise points
        }
    }
    return(distances)
}

distances_to_center <- calculate_distances(coordinates, centroids, cluster_labels)

# 3. Add Distances to the Dataframe
accident_data$DistanceToCenter <- distances_to_center
```

```{r}
# Create a color palette for clusters
cluster_palette <- colorFactor(
  palette = "Set1",
  domain = clustered_accident_data$Cluster
)

# Create a leaflet map with a random sample of points
map <- leaflet() %>%
  addTiles() %>%
  addCircleMarkers(
    data = sample_n(clustered_accident_data, size = 10000),
    lng = ~Longitude,
    lat = ~Latitude,
    color = ~ cluster_palette(Cluster),
    radius = 3,
    popup = ~ paste("Grid Cell:", Cluster)
  )
map
```

```{r}
accident_data <- accident_data[, !(names(accident_data) %in% c(
  "Longitude", "Latitude", "Cluster", "Hour",
  "Date", "Time", "Year", "1st_Road_Class", "2nd_Road_Class",
  "Pedestrian_Crossing-Human_Control", "Pedestrian_Crossing-Physical_Facilities"
))]

accident_data <- accident_data[!is.na(accident_data$Accident_Severity),]
accident_data$Accident_Severity <- factor(accident_data$Accident_Severity)

# Convert all columns to factors
accident_data <- accident_data %>%
  mutate_if(is.character, as.factor)

summary(accident_data)
```

```{r}
# Split the data into training and testing sets
set.seed(123)
train_indices <- sample(nrow(accident_data), nrow(accident_data) * 0.7)
train_data <- accident_data[train_indices, ]
test_data <- accident_data[-train_indices, ]

# Create the logistic regression model
class_weights <- c('0' = 1, '1' = 10)
model <- randomForest(Accident_Severity ~ ., data = train_data, ntree = 20, classwt = class_weights, na.action = na.roughfix)

# Make predictions on the test data
predictions <- predict(model, test_data)
```

```{r}
accuracy <- confusionMatrix(predictions, test_data$Accident_Severity)
print(accuracy$overall['Accuracy'])
```
```{r}
prob_predictions <- predict(model, test_data, type = "prob")

roc_obj <- roc(test_data$Accident_Severity, prob_predictions[,2])
auc_value <- auc(roc_obj)
print(auc_value)
```
```{r}
plot(roc_obj, main="ROC")
```

```{r}
confusion_matrix <- table(predictions, test_data$Accident_Severity)
confusion_matrix
```
