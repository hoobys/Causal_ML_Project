---
title: Causal Machine Learning for Spatial Data Project - UK road safety accidents"
authors: Hubert Wojewoda, Kacper Soko≈Çowski
output: html_notebook
---

```{r}
library(tidyverse)
library(readr)
library(lubridate)
library(ggplot2)
library(sf)
library(here)
library(dbscan)
library(leaflet)
library(geosphere)
library(randomForest)
library(pROC)
library(caret)
library(xgboost)

setwd(here())
```

```{r}
accident_data <- read_csv("accident_data.csv")

summary(accident_data)
head(accident_data)
```

```{r}
unique(accident_data$Year)
```


```{r}
accident_data <- accident_data %>%
  select(
    Longitude, Latitude,
    Accident_Severity,
    Date, Time,
    Weather_Conditions, Light_Conditions,
    Road_Surface_Conditions,
    "1st_Road_Class", "2nd_Road_Class",
    Speed_limit,
    "Pedestrian_Crossing-Human_Control",
    "Pedestrian_Crossing-Physical_Facilities",
    Urban_or_Rural_Area,
    Number_of_Casualties, Number_of_Vehicles
  )
```


```{r}
accident_data <- accident_data %>%
  filter(!is.na(Longitude), !is.na(Latitude))
```

```{r}
accident_data$Accident_Severity <- accident_data$Accident_Severity %>%
  recode("Slight" = 0, "Severe" = 1, "Fatal" = 1)

accident_data$Date <- as.Date(accident_data$Date, format = "%Y-%m-%d")
accident_data$Year <- format(accident_data$Date, "%Y")

accident_data$Day_of_Week <- weekdays(accident_data$Date)
accident_data$Month <- format(accident_data$Date, "%m")
accident_data$Hour <- hour(hms(accident_data$Time))

accident_data$TimeOfDay <- cut(accident_data$Hour,
  breaks = c(-Inf, 6, 12, 18, Inf),
  labels = c("Night", "Morning", "Afternoon", "Evening")
)
```

```{r}
# Convert Longitude and Latitude to a matrix
coordinates <- as.matrix(accident_data[, c("Longitude", "Latitude")])
```

```{r}
# Perform DBSCAN clustering
dbscan_result <- dbscan(coordinates, eps = 0.1, minPts = 500)

# Extract cluster labels
cluster_labels <- dbscan_result$cluster

# Add cluster labels to the accident_data dataframe
accident_data$Cluster <- cluster_labels

# Filter the accident_data dataframe to include only observations in a cluster
clustered_accident_data <- accident_data[accident_data$Cluster > 0, ]
```

```{r}
# Calculate the centroids of the clusters
centroids <- tapply(
  seq_len(nrow(clustered_accident_data)),
  clustered_accident_data$Cluster,
  function(rows) colMeans(clustered_accident_data[rows, 1:2])
)

# Calculate the distance from each point to its closest centroid
accident_data$DistanceToHotspot <- apply(coordinates, 1, function(coord) {
  min(sapply(centroids, function(centroid) dist(rbind(coord, centroid))))
})
```

```{r}
summary(accident_data$DistanceToHotspot)
```

```{r}
# Create a color palette for clusters
cluster_palette <- colorFactor(
  palette = "Set1",
  domain = clustered_accident_data$Cluster
)

# Create a leaflet map with a random sample of points
map <- leaflet() %>%
  addTiles() %>%
  addCircleMarkers(
    data = sample_n(clustered_accident_data, size = 10000),
    lng = ~Longitude,
    lat = ~Latitude,
    color = ~ cluster_palette(Cluster),
    radius = 3,
    popup = ~ paste("Grid Cell:", Cluster)
  )
map
```

```{r}
accident_data <- accident_data[, !(names(accident_data) %in% c(
  "Longitude", "Latitude", "Cluster", "Hour", "Number_of_Casualties",
  "Date", "Time", "Year", "1st_Road_Class", "2nd_Road_Class",
  "Pedestrian_Crossing-Human_Control", "Pedestrian_Crossing-Physical_Facilities"
))]

accident_data <- accident_data[!is.na(accident_data$Accident_Severity), ]

# Convert all columns to factors
accident_data <- accident_data %>%
  mutate_if(is.character, as.factor)

summary(accident_data)
```

```{r}
# Split the data into training and testing sets
set.seed(123)
train_indices <- createDataPartition(
  accident_data$Accident_Severity,
  p = 0.7, list = FALSE
)
train_data <- accident_data[train_indices, ]
test_data <- accident_data[-train_indices, ]

# Create the xgboost model
params <- list(
  objective = "binary:logistic",
  eval_metric = "logloss",
  eta = 0.1,
  max_depth = 4,
  subsample = 0.8,
  colsample_bytree = 0.8
)

# Convert the data to numeric
train_data_numeric <- train_data %>%
  mutate_if(is.factor, as.numeric)
test_data_numeric <- test_data %>%
  mutate_if(is.factor, as.numeric)

# Now use this numeric data in your model
model <- xgboost(
  data = as.matrix(train_data_numeric %>% select(-Accident_Severity)),
  label = train_data$Accident_Severity,
  params = params,
  nrounds = 100
)
# Make predictions on the test data
predictions <- predict(
  model,
  as.matrix(test_data_numeric %>% select(-Accident_Severity))
)
```

```{r}
summary(train_data_numeric)

# Accuracy
mean(ifelse(predictions > 0.5, 1, 0) == test_data$Accident_Severity)
```
```{r}
# AUC score
roc_obj <- roc(test_data$Accident_Severity, predictions)
auc_value <- auc(roc_obj)
print(auc_value)
```
```{r}
# Plot the ROC curve
plot(roc_obj, main = "ROC")
```

```{r}
# Feature importance
xgb.importance(model = model)

# Show importance plot with ggplot2
xgb.importance(model = model) %>%
  as.data.frame() %>%
  ggplot(aes(x = reorder(Feature, Gain), y = Gain)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  theme_bw()
```